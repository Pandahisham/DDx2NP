package es.cbgp.upm.ddxotn.samples.oddx.kbgen;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;

import com.hp.hpl.jena.ontology.ObjectProperty;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.OntResource;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.NodeIterator;
import com.hp.hpl.jena.rdf.model.RDFNode;

import es.cbgp.upm.ddxotn.logic.ConfigManager;
import es.cbgp.upm.ddxotn.logic.DDxDOURIs;
import es.cbgp.upm.ddxotn.nanopub.Nanopub;
import es.cbgp.upm.ddxotn.objects.AssertionTriple;

public class ODDxKBDataExtractor {

	private String DISEASES_FILE;
	private String DDX_ONT_URI;
	private String NAMESPACE;
	private String NAMESPACE_DO;
	private String NAMESPACENANOPUB;

	private ObjectProperty has_sign;
	private ObjectProperty has_disorder;
	private ObjectProperty has_diagnostic_test;
	private ObjectProperty relations[];
	private OntModel model;
	private ArrayList<Physician> physicians;
	private ArrayList<String> informationSources;
	private ArrayList<Disease> diseases;
	private ArrayList<String> dataGeneratedBy;

	/**
	 * Method to execute the nanopub creation process.
	 * 
	 * @throws Exception
	 *             Can throw exceptions.
	 */
	public void execute() throws Exception {
		this.cleanFolder();
		this.loadConfig();
		this.createPhysicians();
		this.createSources();
		this.createDataGeneratedBy();
		this.model = ModelFactory.createOntologyModel();
		this.model.read(DDX_ONT_URI);
		this.has_sign = model.getOntResource(NAMESPACE + "has_sign")
				.asObjectProperty();
		this.has_disorder = model.getOntResource(NAMESPACE + "has_disorder")
				.asObjectProperty();
		this.has_diagnostic_test = model.getOntResource(
				NAMESPACE + "has_diagnostic_test").asObjectProperty();
		this.relations = new ObjectProperty[] { has_sign, has_disorder,
				has_diagnostic_test };
		this.diseases = loadDiseases();
		this.processDiseases();
		System.out.println("Knowledge base nanopubs have been created. Check nanopubs/kb folder");
	}

	private void cleanFolder() throws Exception {
		File f = new File("nanopubs/kb");
		try {
			FileUtils.deleteDirectory(f);
			FileUtils.forceMkdir(f);
		} catch (IOException e) {
			throw new Exception("Error deleting kb directory. Additional info: " + e.getMessage());
		}
	}

	private void loadConfig() throws Exception {
		try {
			DISEASES_FILE = ConfigManager.getConfig("DISEASES_FILE");
			DDX_ONT_URI = ConfigManager.getConfig("DDX_ONT_URI");
			NAMESPACE = ConfigManager.getConfig("NAMESPACE");
			NAMESPACE_DO = ConfigManager.getConfig("NAMESPACE_DO");
			NAMESPACENANOPUB = ConfigManager.getConfig("NAMESPACENANOPUB");
		} catch (Exception e) {
			throw new Exception(
					"Error loading configuration. Additional info: "
							+ e.getMessage());
		}

	}

	/**
	 * Method to create the data generated by
	 */
	private void createDataGeneratedBy() {
		this.dataGeneratedBy = new ArrayList<String>();
		this.dataGeneratedBy.add("Text mining");
		this.dataGeneratedBy.add("Neural networks");
		this.dataGeneratedBy.add("Opinion mining");
		this.dataGeneratedBy.add("Rule mining");
		this.dataGeneratedBy.add("Physician behaviour analysis");
		this.dataGeneratedBy.add("Collective data analysis");
	}

	/**
	 * Create random sources.
	 */
	private void createSources() {
		this.informationSources = new ArrayList<String>();
		this.informationSources.add("Harrisons Medical Book");
		this.informationSources.add("Farreras Medical Book");
		this.informationSources.add("MedLine");
		this.informationSources.add("Wikipedia");
		this.informationSources.add("Physician Expertise");
		this.informationSources.add("Principles of medical diagnosis");
	}

	/**
	 * Method to get a random date.
	 * 
	 * @return Return the date.
	 */
	private Calendar getRandomDate() {
		return getRandomDate(new java.util.Random(System.currentTimeMillis())
				.nextInt(1000));
	}

	/**
	 * Method to get a random date.
	 * 
	 * @param i
	 *            Receives the seed.
	 * @return Return the date.
	 */
	private Calendar getRandomDate(int i) {
		Calendar c = Calendar.getInstance();
		int d = new java.util.Random(System.currentTimeMillis() * (i + 1))
				.nextInt((28 - 1) + 1) + 1;
		int m = new java.util.Random(System.currentTimeMillis() * (i + 2))
				.nextInt((12 - 1) + 1) + 1;
		int y = new java.util.Random(System.currentTimeMillis() * (i + 3))
				.nextInt((2013 - 1990) + 1) + 1990;
		int h = new java.util.Random(System.currentTimeMillis() * (i + 4))
				.nextInt((23 - 1) + 1) + 1;
		int mi = new java.util.Random(System.currentTimeMillis() * (i + 5))
				.nextInt((59 - 1) + 1) + 1;
		int s = new java.util.Random(System.currentTimeMillis() * (i + 6))
				.nextInt((59 - 1) + 1) + 1;
		c.set(y, m, d, h, mi, s);
		return c;
	}

	/**
	 * Once the diseases have been loaded, we create the nanopubs.
	 */
	private void processDiseases() throws Exception {
		for (int i = 0; i < this.diseases.size(); i++) {
			Disease d = this.diseases.get(i);
			/*
			 * Get a random physician for the disease definition.
			 */
			String rndPhysician = getRandomPhysician(i + 1);
			/*
			 * Get a random date.
			 */
			Calendar c = getRandomDate(i);
			processDisease(d, rndPhysician, c);
		}
	}

	/**
	 * Method to process the disease.
	 * 
	 * @param d
	 *            Receives the disease.
	 * @param p
	 *            Receives the physician.
	 * @param c
	 *            Receives the date.
	 */
	private void processDisease(Disease d, String p, Calendar c)
			throws Exception {
		/*
		 * Creates a String to create a random md5 hash based on physician,
		 * disease and calendar.
		 */
		String m5id = d.getId() + p + c.getTime().toString();
		int subs = new java.util.Random(System.currentTimeMillis()).nextInt(27);
		/*
		 * From the entire md5 hash (32 chars) we take a string of random 5.
		 * This is the miniHash
		 */
		String hashDis = DigestUtils.md5Hex(m5id).substring(subs, subs + 5);
		/*
		 * We create the internal ID of the disease (sn:snomedCode:def:miniHash)
		 */
		String internalID = DDxDOURIs.getInstance().SNOMED_ACRONYM + ":"
				+ d.getId() + ":def:" + hashDis;
		/*
		 * We create the nanopub as a md5 based of the internalID.
		 */
		String nanopubID = DigestUtils.md5Hex(internalID);

		/**
		 * We create a list to store the findings that will be created as
		 * separate nanopublications (not as part of the nanocollection)
		 */
		ArrayList<ODDxKBNanopub> nanopubFindings = new ArrayList<ODDxKBNanopub>();

		/**
		 * Nanopub collection.
		 */
		ODDxKBNanopubCollection nc = new ODDxKBNanopubCollection(nanopubID,
				internalID, d.getId(), NAMESPACENANOPUB);
		/*
		 * We want that the publication info triples will be associated to the
		 * nanopub collection, so we create pubinfo data in nanopubcollection.
		 */
		nc.getPublicationInfo().setCreated(c);
		nc.getPublicationInfo().setCreator("Automatic diagnosis KB generator");
		nc.getPublicationInfo().setCreatedBy(p);
		/*
		 * We get the individual of the disease from the ontology
		 */
		OntResource ind = model.getOntResource(NAMESPACE_DO + d.getId());
		if (ind != null) {
			System.out.println("Processing disease: " + d.toString());
			System.out.println("Assigned physician: " + p);
			System.out.println("Date: " + c.getTime());
			System.out.println("internalID: " + internalID);
			System.out.println("nanopubID: " + nanopubID);

			int seed = 1;
			for (int i = 0; i < relations.length; i++) {
				/*
				 * For each possible relation in the ontology we get the
				 * associated individuals.
				 */
				NodeIterator it = ind.listPropertyValues(relations[i]);
				while (it.hasNext()) {
					seed++;
					RDFNode st = it.next();
					System.out.println("\t" + relations[i].getLocalName()
							+ " -> " + st);
					/*
					 * We create a nanopub for the finding. This nanopub will be
					 * part of the nanopubcollection.
					 */
					Nanopub np = createNanopubFinding(st, seed, hashDis, d, p,
							relations[i].getLocalName());
					/*
					 * We add additional provenance data refered to the
					 * relation.
					 */
					np.getProvenance()
							.addAssertionTriple(
									new AssertionTriple(
											DDxDOURIs.getInstance().TEMP_ONTOLOGY_HAS_PROBABILITY_RELATION,
											getRandomPercentage()));
					np.getProvenance()
							.addAssertionTriple(
									new AssertionTriple(
											DDxDOURIs.getInstance().TEMP_ONTOLOGY_RULE_GENERATED_BY_RELATION,
											getRandomRuleGeneratedBy()));
					/*
					 * We add the nanopub to the collection.
					 */
					nc.addNanopub(np);

					/*
					 * Here, we create another nanopub for the same finding, but
					 * this nanopub will not be part of the nanopubcollection.
					 */
					String assertionSubject = np.getAssertion().getObject();
					String internalID2 = np.getInternalID();
					String finding = st.asResource().getLocalName();
					ODDxKBNanopub npf = new ODDxKBNanopub(
							DigestUtils.md5Hex(assertionSubject), internalID2,
							finding, NAMESPACENANOPUB);
					npf.getProvenance().setCreated(getRandomDate());
					npf.getProvenance().setCreator("Creator");
					npf.getProvenance().setSource(
							getRandomInformationSource(finding.length()));
					npf.getAssertion().setSubject(assertionSubject);
					npf.getAssertion().setPredicate(
							DDxDOURIs.getInstance().DDXDO_URI
									+ relations[i].getLocalName());
					npf.getAssertion().setObject(
							DDxDOURIs.getInstance().SNOMED_URI + finding);
					nanopubFindings.add(npf);
				}
			}
			try {
				String baseDir = "nanopubs/kb/" + d.getId() + "/";

				boolean b = new File(baseDir).mkdir();
				if (b) {
					/*
					 * We save the nanopubcollection first (it will
					 * automatically save all the nanopubs include inside)
					 */
					nc.save(baseDir + nc.getNameID() + ".npc");
					/*
					 * For each nanopub that is not in the nanopubcollection, we
					 * save it.
					 */
					for (int i = 0; i < nanopubFindings.size(); i++) {
						ODDxKBNanopub np = nanopubFindings.get(i);
						np.save(baseDir + "CF" + np.getNameID() + ".np");
					}
				} else {
					throw new Exception("Error creating dir " + baseDir);
				}
			} catch (Exception e) {
				throw new Exception("Error saving nanopub. Additional info: "
						+ e.getMessage());
			}
		} else {
			throw new Exception("Error with disease: " + d.toString());
		}
	}

	/**
	 * Method to create a nanopub of a finding.
	 * 
	 * @param st
	 *            Receives the node with the finding snomed id.
	 * @param i
	 *            Receives a numerical value as seed.
	 * @param hashDis
	 *            Receives the hash of the parent disease.
	 * @param d
	 *            Receives the disease object.
	 * @param physician
	 *            Receives the physician.
	 * @param relation
	 *            Receives the relation with the disease.
	 * @return Returns the object.
	 */
	private Nanopub createNanopubFinding(RDFNode st, int i, String hashDis,
			Disease d, String physician, String relation) {
		String infSource = getRandomInformationSource(i);
		String finding = st.asResource().getLocalName();
		Calendar date = getRandomDate();
		String m5id = finding + infSource + date.getTime().toString();
		int subs = new java.util.Random(System.currentTimeMillis()).nextInt(27);
		String hashCf = DigestUtils.md5Hex(m5id).substring(subs, subs + 5);
		String internalID = DDxDOURIs.getInstance().SNOMED_ACRONYM + ":"
				+ d.getId() + ":def:" + hashDis + ":cf:" + hashCf;
		String tmp = internalID + ":" + DigestUtils.md5Hex(internalID);
		String nanopubID = DigestUtils.md5Hex(tmp);
		ODDxKBNanopub np = new ODDxKBNanopub(nanopubID, internalID, finding,
				NAMESPACENANOPUB);
		/*
		 * The nanopubRelationID is the link between this nanopub (part of the
		 * collection) and the other nanopub which represents the same finding.
		 */
		String nanopubRelationID = DigestUtils.md5Hex(internalID);
		/*
		 * We add provenance data.
		 */
		np.getProvenance().setCreated(date);
		np.getProvenance().setCreator(physician);
		np.getProvenance().setSource(infSource);
		/*
		 * We add assertions.
		 */
		np.getAssertion().setSubject(
				DDxDOURIs.getInstance().SNOMED_URI + d.getId());
		np.getAssertion().setPredicate(
				DDxDOURIs.getInstance().DDXDO_URI + relation);
		np.getAssertion().setObject(
				NAMESPACENANOPUB + "/nanopublication/" + nanopubRelationID);
		return np;
	}

	/**
	 * Method to get a random physician.
	 * 
	 * @param i
	 *            Receives the seed.
	 * @return Returns the name.
	 */
	private String getRandomPhysician(int i) {
		return this.physicians.get(
				new java.util.Random(System.currentTimeMillis() + i)
						.nextInt(physicians.size())).getName();
	}

	/**
	 * Method to get a random information source.
	 * 
	 * @param i
	 *            Receives the seed.
	 * @return Returns the name.
	 */
	private String getRandomInformationSource(int i) {
		return this.informationSources.get(new java.util.Random(System
				.currentTimeMillis() + i).nextInt(informationSources.size()));
	}

	/**
	 * Method to get a random rule generated by
	 * 
	 * @return the value.
	 */
	private String getRandomRuleGeneratedBy() {
		return this.dataGeneratedBy.get(new java.util.Random(System
				.currentTimeMillis()).nextInt(dataGeneratedBy.size()));
	}

	/**
	 * Method to get a random decimal value.
	 * 
	 * @return the value.
	 */
	private Double getRandomPercentage() {
		String intPart = Integer.toString(new java.util.Random(System
				.currentTimeMillis()).nextInt(99));
		String decPart = Integer.toString(new java.util.Random(System
				.currentTimeMillis() * Integer.parseInt(intPart)).nextInt(99));
		String v = intPart + "." + decPart;
		return Double.parseDouble(v);
	}

	/**
	 * Method to create the physicians.
	 */
	private void createPhysicians() {
		physicians = new ArrayList<Physician>();
		physicians.add(new Physician("Dr. Sheldon Lee Cooper"));
		physicians.add(new Physician("Dr. Gregory House"));
		physicians.add(new Physician("Dr. Walter White"));
	}

	/**
	 * Method to load the diseases and their information from the file.
	 * 
	 * @return Return the list of diseases.
	 * @throws Exception
	 *             Can throw an exception.
	 * 
	 */
	private ArrayList<Disease> loadDiseases() throws Exception {
		ArrayList<Disease> ret = new ArrayList<Disease>();
		try {
			BufferedReader bL = new BufferedReader(
					new FileReader(DISEASES_FILE));
			while (bL.ready()) {
				String l = bL.readLine();
				String parts[] = l.split("@");
				ret.add(new Disease(parts[0], parts[1], parts[2]));
			}
			bL.close();
		} catch (Exception e) {
			throw new Exception("Error loading the diseases. Additional info: "
					+ e.getMessage());
		}
		return ret;
	}
}
