<!DOCTYPE html> <html> <head> <meta charset="utf-8" /> <title>DDx2NP</title>
</head> <body>

<h1>Introduction</h1>

DDx2NP is <strike>an API</strike> a software (future work will be the orientation of the software to be converted in API) oriented to the generation of <a href="http://nanopub.org">nanopublications</a> of diagnosis knowledge bases schemas or diagnosis results. It allows, for a concrete knowledge base or diagnosis source information, the creation of the associated nanopub following the diagnosis nanopub model.

<h1>Diagnosis nanopub model</h1> 

The Diagnosis nanopub model has been created to provide a reference model to store clinical diagnosis knowledge using nanopublications. The model is divided in two submodels: <em>Diagnosis Knowledge Base Definition Model</em> and <em>Diagnosis Process Definition Model</em>. In order to link the different entities that are represented in both models, as part of the semantic representation we make use of the Diagnosis Definition Ontology (DDxDO), available <a href="http://purl.org/DDXDO/">here</a>.

 <h2>Diagnosis Knowledge Base Definition Model</h2>
 
 The Diagnosis Knowledge Base Definition Model (DKBD Model) has been created to provide a real structure about how the diagnostic criteria of the diseases are conformed, also known as Diagnostic Criterion Model (DCM) [1]. DKBD uses the DCM model as a way to create relations between the disease and the associated criteria (clinical findings).
 The basic representation of this model, using DDxDO to create the relationships,  can be seen on the following Figure:<br/>
 <br/>
 
 <div align="center"><img src="fig1.png" alt="" /></div>
 <br/>
 <br/> 
 
 The definition of a disease is the definition done by a physician/system about a disease in a concrete moment. For each disease-physician/system pair  several
 definitions could exist, based on several factors (that should be reflected in publication info data). This schema allows having multiple definitions of a same
 disease made by several physicians or systems. In the left part of the schema we have a nanopublication collection to define a disease. This nanopublication
 collection is linked with other nanopublications through the <i>has_clinical_finding_definition</i> relationships, following the DCM model. The nanopublication collection is a set of nanopublications with shared publication info. Each nanopublication inside the nanopublication collection has a set of assertions and provenance data that makes reference to the entire nanopublication. In the model, each nanopublication which belongs to the nanopublication collection contains information about the clinical finding that has been asserted to "be part" of the disease. In the assertion part of the nanopublication, we will have a definition of this relation through the <i>has_clinical_finding_definition relation</i>, being the object (or end) of this relation, the nanopublication that is out of the collection. Provenance data will contain information regarding the assertion of the nanopublication of the nanopublication collection. On the other hand, the nanopublications that are out of the nanopublication collection contain more specific data about the clinical finding. Basically, they can contain different types of relations with the finding (<i>has_sign</i>, <i>has_diagnostic_test</i>, <i>has_disorder</i>, etc ...) depending the type of clinical finding, and other provenance information regarding this relation. The following figure shows a more detailed example of this model; we can see a hypothetical example of a disease definition using this model: 
 
 <br/><br/>  <div align="center"><img src="fig2.png"/></div> <br/><br/> 
 
 As can be seen in this figure, we have the definition of disease with snomed code <i>458</i>. In the nanopub collection we have the following elements:</br></br>
 
 A common publication info data: This data contains information about who create the diagnostic criterion for this disease. In the example provided, Dr. House is the creator, and we have more information such as date, version, etc. Each nanopublication contained in the nanocollection is a finding associate to the disease. In this example, we have two different nanopubs (<i>sn:dx458:def:a413f:np1</i> and <i>sn:dx458:def:a413f:np2</i>). The aim of each nanopublication of the nanocollection is to link with the findings that conform the diagnostic criteria. Given that current nanopublications model didn't allow to have assertion data for a nanocollection, it is necessary to duplicate the data about the disease so many times as clinical findings we have. That's the reason because we have duplicated the <i>codeRepresentation</i> data in both nanopubs.</br></br>
 
 The most important triple of the assertion data is the one which links with the real data of the clinical finding through the relation <i>has_clinical_finding_definition</i>.</br></br>
 
 On the right side of the figure we have the nanopublications which represents the information of the finding. Assertion data contains several triples, including those which  types the nanopublication content as <i>ClinicalFindingDefinition</i> and makes a relation between the <i>ClinicalFindingDefinition</i> and the type of finding (<i>Sign</i>) through the <i>has_sign</i> relationship.</br></br>

 Finally, the following figure shows the definition of the same disease performed by two different physicians following DKBD Model:
 
 <br/><br/> <div align="center"><img src="fig3.png"></div> <br /><br/>

<h2> Diagnosis Process Definition Model</h2> 

The Diagnosis Process Definition Model (DPD Model) has been created with the aim of storing information about the diagnosis performed by physicians or diagnostic systems,including information that will allow  to keep a tracking about the diagnostic process, including information about how a physician or a system reaches a diagnosis. The basic representation of the DPDomodel can be seen on figure 4.

<br/><br/> <div align="center"><img src="fig4.png"/></div> <br/><br/>

In this model, we have a nanopublication collection which represents the input data of the patient. In this collection all the findings that the patient manifested and should be considered in the diagnosis process are included. On the other hand, we have a nanopublication for each diagnosed disease. If a physician or system reaches the decision that several diseases can be the diagnostic result, one nanopublication per disease should be created. The nanopublication which contains the diagnosis has the following elements:</br>
<ul><li><b>Assertion</b>: In the assertion section there is a triple that relates the patient (using the patient ID [subject]) with the proposed disease [object] through the <i>diagnosis</i> relation from the DDxDO ontology. There also several other triples to type the data and assign a SNOMED code to the diagnosed disease.</li> 

<li><b>Provenance</b>: Provenance  data provides information about how this diagnosis was reached. First of all, it has direct references to the nanopublication collection that contains the data about the patient in order to track where the clinical findings of the patient came from. The relation <i>has_input_data</i> of DDxDO ontology is used.</li>

Provenance also contains information about what findings help the physician or system to reach the diagnosis. It contains several triples that link the diagnosis nanopublication with the supporting nanopublications through the <i>has_clinical_finding_definition</i> relation, being the subject the patient ID and  the object the supporting nanopublication. The supporting nanopublications contain information about the finding which helps to reach the diagnosis. Assertion provides triples about what finding was considered (in a positive or negative way) to perform the diagnosis. Provenance information can contain any other data relevant to the finding such as how it was confirmed. A working example of the schema with two hypothetical diagnoses for a same input data is shown as follows: </ul>

<br/><br/> <div align="center"><img src="fig5.png"/></div> <br/><br/>

<h1>Data Example</h1>

As part of the development of DDx2NP we have created a simulated scenario where we generate a set of nanopublication files which contains information about a certain knowledge base and a solved clinical case. You can download a sample of both elements (knowledge base and clinical case) which has been transformed to allow a human-readable format of the nanopublication.</br></br>

-> <a href="npsample.zip">Download</a> <-</br>

<h1>How to create nanopubs for a concrete diagnosis model</h1>

The development of an API capable of work with any knowledge base is a complex task. Depending on how the knowledge base has been created and organized there are several ways that can be used to load the data and create the nanopublications according the proposed schema. For this reason, current version of our software is just this: a software.

The software has been designed and developed trying to be as standard, flexible and robust as possible. However, if you want to convert your diagnosis knowledge base to nanopublications following the schema proposed by DDx2NP with DDxDO ontology you need to adapt your data. Current version requires some tricky code development to work, 
but we are working on its improvement. It is important to notice that the current version is limited to a set of provenance and publication data info. This means that the vocabularies and properties used are built-in in the current version of the code. If you want to include new data, you have to re-code basis of DDx2NP. Regarding this, two problems emerge:
<ol>
<li><b>Source</b>: Where is your data stored? This is the first important question. Maybe your data is stored on an ontology with its own schema. 
 Maybe you have your data on a database or in plain text files with your own format/schema. Given this situation, you have to create your 
 own code to extract all your knowledge from your source, creating objects that can be manipulated by DDx2NP.</li>
 
 <li><b>Data</b>: The structure of your data is the first Problem. Maybe you have a concrete model to store your diagnosis information based on your requirements and hence, the relations differ to the ones proposed by DDx2NP. The second problem is the data itself. We don't know what information/knowledge you have. And more important, we don't know what you want to convert to nanopub or dismiss.</li>
</ol>

Given this situation, the creation of nanopublications from your data source is not an easy task. It will not be difficult, but.. Neither easy. The best approach that we recommend to follow is to check the samples provided by the API. In the samples, you have two packages: <br/><br/>

es.cbgp.upm.ddxotn.samples.oddx.kbgen

<br/><br/>

ODDx [1-4] is the legacy diagnostic system that we have used as an example. It contains a knowledge base about diseases and their associated findings using DCM model. We have created a set of classes that allows extracting the information from the ODDx platform and converting it to nanopublications using the DKBD model. This package contains the following classes:
<ul>
<li><b>Disease</b>: It is a small object which contains basic information about a disease such as name, ID (Snomed ID) and description.</li>
<li><b>Physician</b>: It is a small object which contains basic information about the physician which designs the diagnostic criterion of the disease. In this case, 
only contains the name, but more data could be added.</li>
<li><b>ODDxKBDataExtractor</b>: This class is in charge of loading all the data from the source. In this case, it extracts the diseases of the knowledge base from a separate 
text file along the name, snomed code and description. Once the disease objects have been created, it gets the relation with other findings from the ODDx 
ontology [5] and processes each disease in order to generate the associated nanopub.</li>
<li><b>ODDxKBNanopubCollection</b>: In the nanopub version of the knowledge base each disease is represented by a nanopub collection. This class, which extends from 
NanopubCollection class of DDx2NP API, currently, forces to implement one method: createPublicationInfoQuads. This method is in charge of creating the 
publication info quads. Basically, you have to create the quads (using createQuad method) of the publication info data. The quads that can be created are 
limited to the information available in DDx2NP API unless you modified the code.</li>
<li><b>ODDxKBNanopub</b>: In the nanopub version of the knowledge base each clinical finding is represented by a nanopub. This class, which extends from Nanopub class 
of DDx2NP API, currently, forces to implement these methods:
<ul>
<li><b>createAssertionQuads</b>: This method allows to create the assertion quads. Any assertion can be added.</li>
<li><b>createProvenanceQuads</b>: This method allows to create the provenance quads. Provenance are limited to the information available in DDx2NP API.</li>
</ul>
</li>
</ul>

The second package available in the samples is the diagnosis package:
<br /><br />
es.cbgp.upm.ddxotn.samples.oddx.diagnosis
<br /><br />
The behavior is similar. We have the following classes:
<ul>
<li><b>ClinicalCase</b>: Clinical Case class represents a hypothetical clinical case. It contains information about the patient and the diagnoses reached.</li>
<li><b>Patient</b>: This class contains information about the patient (signs and diagnostic tests as clinical findings) and the ID.</li>
<li><b>Diagnosis</b>: The diagnosis contains information about the diagnosed disease and the physician or system which perform it.</li>
<li><b>ODDxDiagnosisDataExtractor</b>: This class is in charge of load all the data from the source. In this case, it extracts all the data from a set of files 
which contains information about each clinical case (input findings manifested by the patient, and the diagnoses made by different physicians and the 
evaluated system).</li>
<li><b>ODDxDiagnosisNanopubCollection</b>: In the diagnosis process a nanopubcollection is used to store patient input data. Each nanopub included in this 
collection contains information about the findings manifested by the patient with attached provenance information. As in the previous case, this 
class extends from NanopubCollection and is forced to implement createPublicationInfoQuads method.</li>
<li><b>ODDxDiagnosisNanopub</b>: In the diagnosis process, this nanopub is used to store information about:
<ul>
<li>Information about the findings manifested by the patient.</li>
<li>Diagnosis performed.</li>
<li>Findings supporting the diagnosis.</li>
</ul>
</li>
</ul>
Following the samples provided in the API it is possible to create personalized classes to create your own nanopubs associated to your diagnosis schema.
<br /><br />
[1] Rodriguez-Gonzalez, A. and Alor-Hernandez, G. (2013). An approach for solving multi-level diagnosis in high sensitivity medical diagnosis systems through the application of semantic technologies. Computers in Biology and Medicine 43(1), pp. 51-62.
<br />
[2] Garcia-Crespo, A., Rodriguez-Gonzalez, A., Mencke, A., Gomez-Berbis, J.M., Colomo-Palacios, R. (2010). ODDIN: Ontology-driven differential diagnosis based on logical inference and probabilistic refinements. Expert Systems With Applications 37(3), pp. 2621-2628
<br />
[3] Rodriguez-Gonzalez, A., Labra-Gayo, J.E., Alor-Hernandez, G., Gomez-Berbis, J.M., Posada-Gomez, R. (2009). ADONIS: Automated Diagnosis System based on Sound and Precise Logical Descriptions. 22nd IEEE International Symposium on Computer-Based Medical Systems
<br />
[4] Rodriguez-Gonzalez, A., Labra-Gayo, J.E., Colomo-Palacios, R., Mayer, M.A., Gomez-Berbis, J.M., Garcia-Crespo, A. (2012). SeDeLo: using semantics and description logics to support aided clinical diagnosis. Journal of Medical Systems 36(4), pp. 2471-2481
<br />
[5] Rodriguez-Gonzalez, A., Hernandez-Chan, G., Colomo-Palacios, R., Gomez-Berbis, J.M., Garcia-Crespo, A., Alor-Hernandez, G., Valencia-Garcia, R. (2012). Towards an Ontology to Support Semantics Enabled Diagnostic Decision Support Systems. Current Bioinformatics 7(3), p.. 234-245


  </body> </html>
